// OPERATOR OVERLOADING
// THE MECHANISM OF GIVING SOME SPECIAL MEANINGS TO AN OPERATOR IS CALLED OPERATOR OVERLOADING

// WE CAN OVERLOAD ALL THE C++ OPERATORS EXCEPT- . , .* , :: , sizeof, ?:
// THESE OPERATORS TAKE NAME (CLASS NAME) AS OPERANDS INSTEAD OF VALUES

// OPERATOR OVERLOADING CANNOT CHANGE THE SYNTAX AND GRAMMATICAL RULES THAT GOVERNS IT'S USE SUCH AS NUMBER OF OPERANDS, PRECEDENCE AND ASSOSCIAVITY
// (MULTIPICATION OPERATOR WILL ENJOY HIGHER PRECEDENCE THAN ADDITION OPERATOR)

// ALSO WHEN AN OPERATOR IS OVERLOADED IT'S ORIGINAL MEANING IS NOT LOST (SEMANTICS OF OPERATOR CAN BE EXTENDED)
// (SO + USED FOR ADDITION OF TWO VECTORS CAN STILL BE USED FOR SIMPLE ADDITION)

// OPERATOR FUNCTION
// TO DEFINE AN ADDITIONAL TASK TO AN OPERATOR, WE USE OPERATOR FUNCTION

//  GENERAL FORM
//  return_type class_name :: operator op(arglist){      -> operator is keyword
//                                                       -> op is +, *, ...
//      function body
//
//  }

// OPERATOR FUNCTION MUST BE EITHER MEMBER FUNCTION (NON STATIC) OR FRIEND FUNCTIONS
// BASIC DIFFERENCE IS THAT FRIEND FUNCTION WILL HAVE ONE ARGUMENT FOR UNARY OPERATOR AND TWO ARGUMENTS FOR BINARY OPERATORS
// WHILE MEMBER FUNCTION WILL HAVE NO ARGUMENT FOR UNARY OPERATOR AND SINGLE ARGUMENT FOR BINARY OPERATORS
// THIS IS SO BECAUSE THE OBJECT USED IN INVOKING THE MEMBER FUNCTION IS PASSED IMPLICITLY AND THEREFORE IS AVAILABLE FOR THE MEMBER FUNCTION
// WHILE THAT IS NOT THE CASE FOR FRIEND FUNCTION

// OPERATOR FUNCTION PROTOTYPES ( THIS WILL BE MORE CLEAR IN NEXT TWO FILES )
// vector operator+(vector);  -> member function which return a vector by adding it to another vector passed
// friend vector operator+(vector, vector) -> friend function so pass both the vectors to add
// vector operator~() -> no arg for unary operator
// friend vector operator~(vector) -> one arg for friend func